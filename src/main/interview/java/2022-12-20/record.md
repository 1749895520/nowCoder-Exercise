# 2022-12-20

---

**选A**

Set不能有重复的元素，且是无序的，要有空值也就只能有一个。因为它不允许重复。List可以有重复元素，且是有序的，要有空值也可以有多个，因为它可重复

---

**java Thread中，run方法和start方法的区别，下面说法错误的是？**

A、通过调用Thread类的start()方法来启动一个线程，这时此线程是处于就绪状态，并没有运行。

B、他们都可以实现了多线程运行。

C、run方法是thread的一个普通方法调用。

D、调用start方法后，一旦得到cpu时间片，就开始执行run()方法。

**选B**

两种方法的区别:

1.start方法

用 start方法来启动线程，是真正实现了多线程， 通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法。但要注意的是，此时无需等待run()

方法执行完毕，即可继续执行下面的代码。所以run()方法并没有实现多线程。

2.run方法

run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码。

---

**java用（）机制实现了线程之间的同步执行**

A、监视器

B、虚拟机

C、多个CPU

D、异步调用

**选A**

首先jvm中没有进程的概念，但是jvm中的线程映射为操作系统中的进程，对应关系为1：1。那这道题的问的就是jvm中线程如何异步执行。在jvm中是使用监视器锁来实现不同线程的异步执行，在语法的表现就是synchronized。

---

**（）运算符把其操作数中所有值为0和所有值为1的位分别在结果的相应中设置1和0**

A、&

B、|

C、！

D、~

**选D**

&与操作；

|或操作；

！非操作；

~取反操作；

---

**代码片段：**

```java
class Test {
    public static void main(String[] args) {
        byte b1 = 1, b2 = 2, b3, b6;
        final byte b4 = 4, b5 = 6;
        b6 = b4 + b5;
        b3 = (b1 + b2);
        System.out.println(b3 + b6);
    }
}
```

**关于上面代码片段叙述正确的是（）**

A、输出结果：13

B、语句：b6=b4+b5编译出错

C、语句：b3=b1+b2编译出错

D、运行期抛出异常

**选C**

被final修饰的变量是常量，这里的b6=b4+b5可以看成是b6=10；在编译时就已经变为b6=10了

而b1和b2是byte类型，java中进行计算时候将他们提升为int类型，再进行计算，b1+b2计算后已经是int类型，赋值给b3，b3是byte类型，类型不匹配，编译不会通过，需要进行强制转换。

Java中的byte，short，char进行计算时都会提升为int类型。

---

**以下代码可以使用的修饰符是：（）**

A、final

B、static

C、abstract

D、public

**选ABD**

接口中字段的修饰符：public static final（默认不写）

接口中方法的修饰符：public abstract（默认不写）

---

**下列说法正确的是（）？**

A、我们直接调用Thread对象的run方法会报异常，所以我们应该使用start方法来开启一个线程

B、一个进程是一个独立的运行环境，可以被看做一个程序或者一个应用。而线程是在进程中执行的一个任务。Java运行环境是一个包含了不同的类和程序的单一进程。线程可以被称为轻量级进程。线程需要较少的资源来创建和驻留在进程中，并且可以共享进程中的资源

C、synchronized可以解决可见性问题，volatile可以解决原子性问题

D、ThreadLocal用于创建线程的本地变量，该变量是线程之间不共享的

**选BD**

C选项，volatile不能保证原子性问题

---

**在使用super和this关键字时，以下描述错误的是（）**

A、在子类构造方法中使用super()显示调用父类的构造方法，super()必须写在子类构造方法的第一行，否则编译不通过

B、super()和this()不一定要放在构造方法内第一行

C、this()和super()可以同时出现在一个构造函数中

D、this()和super()可以在static环境中使用，包括static方法和static语句块

**选BCD**

A选项正确，
B选项，super()必须在第一行的原因是: 子类是有可能访问父类对象的, 比如在构造函数中使用父类对象的成员函数和变量, 在成员初始化使用了父类, 在代码块中使用了父类等等,
所以为保证在子类可以访问父类对象之前，一定要完成对父类对象的初始化。 关于this()必须在第一行的原因，我们假设这样一种情况,，类B是类A的子类， 如果this()可以在构造函数的任意行使用, 那么当程序运行到构造函数B()
的第一行,发现没有调用this()和super()，那么就会自动在第一行补齐super() 来完成对父类对象的初始化, 然后返回子类的构造函数继续执行, 当运行到构造函数B()的"this() ;"时, 调用B类对象的构造函数,
还会对父类对象再次初始化!，这就造成了资源的浪费，以及某些意想不到的错误。也正因如此C选项错误。

D选项，无论是this()还是super()指的都是对象，而static环境中是无法使用非静态变量的。因此D选项错误。

---

**关于volatile关键字，下列描述不正确的是？**

A、用volatile修饰的变量，每次更新对其他线程都是立即可见的。

B、对volatile变量的操作是原子性的。

C、对volatile变量的操作不会造成阻塞。

D、不依赖其他锁机制，多线程环境下的计数器可用volatile实现。

**选BD**

一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义： 1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 2）禁止进行指令重排序。
volatile只提供了保证访问该变量时，每次都是从内存中读取最新值，并不会使用寄存器缓存该值——每次都会从内存中读取。 而对该变量的修改，volatile并不提供原子性的保证。
由于及时更新，很可能导致另一线程访问最新变量值，无法跳出循环的情况 多线程下计数器必须使用锁保护。
